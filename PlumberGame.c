/*水管工游戏
 *《啊哈》
 *规则：一块儿矩形土地被分为N*M的单位正方形，土地下埋有水管。水管将从坐标(0,0)的左上角坐部边缘延伸到(N-1,M-1)右下角右部边缘
 *      水管只有两种：直的和弯的。每种管道将占据一个单位正方形土地。旋转管道，使其构成一个管道系统，即创造从(0,0)到(N-1,M-1)的
 *      连通管道。标有树木的方格表示没有管道。如果旋转管道可以是指构成一个连通的管道系统，就输出铺设路径，否则，输出impossible
 *分析：！！！拿过问题，不要被吓到，试一下怎么玩儿，然后一步步的想解决方法，其实，并不难的
 *      建模：0表示树木，而管道有两种，直的和弯的。直的有两种形态，弯的有4种形态。故，1~6分别表示管道的六种不同的摆放方式。
 *           //看书找图，形象些
 *      首先，从(0,0)处开始尝试，(0,0)是直管，且进水口在左边，所以只能使用5号这种形态的摆放方式。之后到达(0,1),...依次往下分析，
 *      直到(n-1,m)为止！！！(不是m-1哦)
 *      对于(x,y)，需要依次枚举当前管道的每一种摆放方式，直管2种，弯管4种。并且，并不是每一种都可以的，还需判断进水口的方向。
 *      为方便，将进水口在左、上、右、下分别表示为1、2、3、4。
 *      使用DFS算法
 *      为输出路径，还需要加入一个栈
 *测试数据：
 *5 4
 *5 3 5 3
 *1 5 3 0
 *2 3 5 1
 *6 1 1 5
 *1 5 5 4
 *输出:(0,0)->(0,1)->(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(5,4)
 *
 *优化:从文件中读取地图
*/

#include <stdio.h>
int map[50][50];//根据题目要求来，这里假设土地大小不超过50*50
int book[50][50];
int n,m;//土地大小n行m列
int flag;//标记是否找到

struct note
{
    int x;//横坐标
    int y;//纵坐标
}s[100];
int top = -1;//栈

void dfs(int x,int y,int front)//当前位置的坐标及入水口方向
{
    int i;
    //判断是否到达终点，注意，y坐标为m！！
    //！！！判断是否到达终点一定要放在越界判断的前面
    if(x==n-1 && y==m)
    {
        flag=1;//找到铺设方案
        for(i=0;i<=top;++i)//多加了一个;，致使结果输出有误!!!
            printf("(%d,%d)->",s[i].x,s[i].y);
        printf("(%d,%d)\n",n,m);
        return;
    }

    //判断是否越界
    if(x<0 || x>=n || y<0 || y>=m)
        return;
    //判断管道是否在路径中已经使用过
    if(book[x][y] == 1)
        return;
    book[x][y] = 1;//标记使用当前管道

    //将当前尝试的管道入栈
    top++;
    s[top].x=x;
    s[top].y=y;

    //当前管道是直管的情况
    if(map[x][y]>=5 && map[x][y]<=6)
    {
        if(front == 1)//进水口在左
            dfs(x,y+1,1);//只能使用5这种摆放方式
        if(front == 2)//在上
            dfs(x+1,y,2);//只能6
        if(front == 3)//右
            dfs(x,y-1,3);//只能5
        if(front == 4)//下
            dfs(x-1,y,4);//只能6
    }

    //当前管道式弯管的情况
    if(map[x][y]>=1 && map[x][y]<=4)
    {
        if(front == 1)//进水口在左边
        {
            dfs(x+1,y,2);//3号状态
            dfs(x-1,y,4);//4号状态
        }
        if(front == 2)//上
        {
            dfs(x,y+1,1);//1号状态
            dfs(x,y-1,3);//4号
        }
        if(front == 3)//右
        {
            dfs(x-1,y,4);//1
            dfs(x+1,y,2);//2
        }
        if(front == 4)//下
        {
            dfs(x,y+1,1);//2
            dfs(x,y-1,3);//3
        }
    }

    book[x][y] = 0;//取消尝试标记!!!
    top--;//将当前尝试的坐标出栈!!!
    return;
}   

int main()
{
    int i,j;//循环控制变量
    printf("请输入游戏地图的行、列：");
    scanf("%d %d",&n,&m);
    //读入游戏地图
    printf("请输入%d行%d列的地图：\n",n,m);
    for(i=0;i<n;++i)
        for(j=0;j<m;++j)
            scanf("%d",&map[i][j]);
    //开始搜索，从(0,0)开始，进水方向为1
    dfs(0,0,1);
    //判断是否找到铺设方案
    if(flag==0)
        printf("\nimpossible\n");

    return 0;
}







