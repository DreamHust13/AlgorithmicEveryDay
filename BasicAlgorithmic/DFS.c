/*图的深度优先搜索
 *算法：首先以一个未被访问过的顶点作为其实顶点，沿当前顶点的边走到未被访问过的顶点；当没有未被访问过的顶点时，则回到上一顶点，
 *      继续试探式访问别的顶点，知道所有顶点都被访问过。即沿着图的某一条分支遍历直到末端，然后回溯，再沿另一条进行同样的遍历，
 *      直到所有顶点都被访问过为止
 *实现：图的存储：
 *              使用矩阵，图的邻接矩阵存储法((i,j)表示顶点i和j之间是否有边)
 *规则：使用DFS搜索图
 *
*/

#include <stdio.h>
int book[100];//标记数组
int sum;//记录已经访问的顶点数
int n;//图中的总顶点数
int edge[100][100];//边集

void dfs(int cur)//cur为当前顶点的编号
{
    int i;
    printf("%d ",cur+1);
    sum++;//每访问一个顶点，sum就加1
    if(sum==n)
        return;//所有顶点都访问过，就返回
    for(i=0;i<n;++i)//尝试依次访问n个顶点，看哪些顶点与当前顶点cur有边相连
    {
        //判断当前顶点cur到i是否有边，并判断顶点i是否已访问过
        if(edge[cur][i] == 1 && book[i]==0)
        {
            book[i]=1;//标记i已访问
            dfs(i);//从i再出发访问
        }
    }
    return;
}

int main()
{
    int i,j;//循环控制变量
    int m;//边数
    int a,b;//输入边时的临时变量
    printf("请输入顶点数、边数：");
    scanf("%d %d",&n,&m);
    //初始化二维矩阵
    for(i=0;i<n;++i)
        for(j=0;j<n;++j)
            if(i==j)
                edge[i][j]=0;
            else
                edge[i][j]=99999999;//假设99999999为正无穷

    printf("请输入边集(两点之间的边之输入一条即可)：\n");
    //读入边集
    for(i=0;i<m;++i)
    {
        scanf("%d %d",&a,&b);
        edge[a-1][b-1] = 1;
        edge[b-1][a-1] = 1;//无向图，对称
    }

    book[0] = 1;//标记顶点1已被访问
    printf("顶点访问顺序为：");
    dfs(0);

    return 0;
}
